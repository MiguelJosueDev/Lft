# CLAUDE – Reglas globales del proyecto LFT

Eres un asistente de código trabajando en el proyecto **LFT** (LiveFree Template Engine).

---

## Arquitectura General

Antes de proponer cambios de arquitectura o contratos compartidos, **lee**:

- `./docs/architecture.md` (si existe)
- `./docs/conventions.md` (si existe)
- `./LFT_ENGINE_DETAILED_REPORT.md` - Documentación técnica completa del Engine
- `./TESTING_GUIDE.md` - Guía de testing del proyecto

### Módulos del Proyecto

```
Lft/
├── src/
│   ├── Lft.Domain/          # Núcleo estable - Modelos compartidos
│   ├── Lft.Engine/          # Motor de generación de código (template-based)
│   └── Lft.Cli/             # CLI - Capa delgada de presentación
└── tests/
    └── Lft.Engine.Tests/    # Tests del Engine (100 tests)
```

---

## Reglas Fundamentales

### 1. Separación de Responsabilidades

**Lft.Domain** (Núcleo Estable)
- ✅ Contiene SOLO modelos de datos compartidos
- ✅ NO tiene lógica de negocio
- ✅ NO tiene dependencias externas
- ❌ NO modificar a menos que la tarea lo pida EXPLÍCITAMENTE
- Modelos actuales:
  - `GenerationRequest` - Input del proceso de generación
  - `GenerationResult` - Output del proceso de generación
  - `GeneratedFile` - Representa un archivo generado

**Lft.Engine** (Capa de Aplicación)
- ✅ Contiene TODA la lógica de generación de código
- ✅ Consume contratos de `Lft.Domain`
- ✅ Extensible vía interfaces (`ICodeGenerationEngine`, `IVariableProvider`, `ITemplateRenderer`)
- ❌ NO debe contener lógica de UI
- ❌ NO debe tener dependencias del CLI
- ❌ NO debe escribir a Console directamente (usar logging)
  - **Excepción actual:** `DiskFileWriter.WriteFileAsync` usa `Console.WriteLine` para logs
  - **TODO:** Refactorizar a ILogger en futuro

**Lft.Cli** (Capa de Presentación)
- ✅ Delgada: SOLO configura y ejecuta
- ✅ Parsea argumentos del usuario
- ✅ Configura Dependency Injection
- ✅ Ejecuta el Engine
- ✅ Escribe archivos a disco
- ❌ NO contiene lógica de negocio
- ❌ NO contiene lógica de templates
- ❌ NO contiene lógica de variables

---

## Reglas Específicas del Engine

### Arquitectura del Engine

El Engine sigue un patrón de pipeline:

```
GenerationRequest
    ↓
TemplatePackLoader → Carga YAML
    ↓
VariableResolver → Resuelve variables (Providers)
    ↓
StepExecutor → Ejecuta pasos (Rendering)
    ↓
GenerationResult → Lista de archivos generados
```

### Componentes Clave

#### 1. **ICodeGenerationEngine** - Punto de Entrada
- ✅ Interface estable
- ✅ Única implementación: `TemplateCodeGenerationEngine`
- ❌ NO crear múltiples implementaciones sin justificación

#### 2. **Variables Module** - Sistema de Resolución de Variables
- **IVariableProvider** - Contrato para providers
  - Implementaciones: `CliVariableProvider`, `ConventionsVariableProvider`
  - ✅ EXTENSIBLE: Puedes agregar nuevos providers
  - ✅ Usa patrón Strategy

- **VariableContext** - Almacenamiento case-sensitive
  - ⚠️ **CRÍTICO:** Usa `StringComparer.Ordinal` (NO cambiar a OrdinalIgnoreCase)
  - ⚠️ Bug histórico resuelto: `_ModelName` ≠ `_modelName`
  - ✅ Test que previene regresión: `Set_WithDifferentCaseKeys_ShouldStoreSeparately`

- **ConventionsVariableProvider** - Generador de convenciones
  - ✅ Usa Humanizer para pluralización (Person→People)
  - ✅ Genera 14 variables estándar
  - ✅ Cobertura: 51 tests (pluralización, kebab-case, edge cases)
  - ❌ NO remover variables sin verificar impacto en templates

#### 3. **Templates Module** - Configuración YAML
- **TemplatePack** - Modelo de datos para YAML
  - ✅ Estructura jerárquica (EntryPoints → Steps)
  - ⚠️ Limitación conocida: No soporta `!include` (TODO: Sprint 3)

- **TemplatePackLoader** - Deserializa YAML
  - ✅ Usa YamlDotNet con CamelCaseNamingConvention
  - ❌ NO cambiar naming convention sin actualizar YAMLs

#### 4. **Steps/Rendering Module** - Ejecución
- **StepExecutor** - Ejecuta pasos recursivamente
  - ✅ Soporta acciones: "group" (contenedor) y "create" (generar archivo)
  - ✅ Usa recursión para procesar jerarquías
  - ❌ NO agregar acciones nuevas sin actualizar documentación

- **LiquidTemplateRenderer** - Renderiza Liquid templates
  - ✅ Usa Fluid.Core 2.31.0
  - ✅ Soporta: variables (`{{ }}`), condicionales (`{% if %}`), loops (`{% for %}`)
  - ⚠️ Limitación: No accede a propiedades de objetos anónimos vía dynamic
  - ❌ NO cambiar `MemberNameStrategies.Default`

#### 5. **File I/O Module**
- **DiskFileWriter** - Escribe a disco
  - ✅ Crea directorios automáticamente
  - ✅ Protege archivos existentes (overwrite=false por defecto)
  - ⚠️ Usa Console.WriteLine (TODO: migrar a ILogger)

---

## Testing - Reglas Estrictas

### Cobertura Actual
- ✅ **100 tests** (96% passing, 4% con limitaciones conocidas)
- ✅ **73 tests** de Variables Module
- ✅ **27 tests** de Rendering/Integration
- ❌ **0 tests** de TemplatePackLoader (TODO)
- ❌ **0 tests** de DiskFileWriter (TODO)

### Reglas de Testing

1. **SIEMPRE escribir tests para:**
   - Nuevos IVariableProvider
   - Cambios en ConventionsVariableProvider
   - Cambios en VariableContext
   - Nuevas acciones en StepExecutor

2. **Patrón AAA obligatorio:**
   ```csharp
   [Fact]
   public void MethodName_Scenario_ExpectedBehavior()
   {
       // Arrange - Configurar
       var request = new GenerationRequest("Entity", "csharp");

       // Act - Ejecutar
       var result = _provider.Populate(context, request);

       // Assert - Verificar
       result.Should().Be(expected);
   }
   ```

3. **Usar [Theory] para múltiples casos:**
   ```csharp
   [Theory]
   [InlineData("Person", "People")]
   [InlineData("Category", "Categories")]
   public void Pluralize_WithIrregulars_ShouldBeCorrect(string singular, string plural)
   ```

4. **Tests de regresión obligatorios para bugs:**
   - ✅ Ejemplo: `Set_WithDifferentCaseKeys_ShouldStoreSeparately` previene bug de case-sensitivity
   - Si encuentras un bug, ESCRIBE un test que lo reproduzca ANTES de arreglarlo

5. **Documentación de tests:**
   - Actualizar `TESTING_GUIDE.md` si agregas nueva categoría de tests
   - Actualizar `TEST_SCENARIOS_EXPLAINED.md` si hay escenarios complejos

---

## Dependencias Externas

### NuGet Packages (NO modificar versiones sin justificación)
- **Fluid.Core 2.31.0** - Motor Liquid (core del rendering)
- **Humanizer.Core 2.14.1** - Pluralización/transformaciones (CRÍTICO para calidad)
- **YamlDotNet 16.3.0** - Deserialización YAML

### Reglas:
- ❌ NO actualizar Humanizer sin re-ejecutar los 51 tests de pluralización
- ❌ NO cambiar Fluid sin verificar los 27 tests de rendering
- ✅ PUEDE agregar nuevas dependencias si están bien justificadas

---

## Convenciones de Código

### Naming Conventions

**Variables generadas (14 estándar):**
```
_EntityPascal         → "FundingType"
_EntityPlural         → "FundingTypes"
_EntityKebab          → "funding-type"
_ModelName            → "FundingType"
_ModuleName           → "FundingTypes"
BaseNamespaceName     → "Lft.Generated"
keyType               → "long"
isMql                 → false
isRepositoryView      → false
MainModuleName        → "Generated"
_MainModuleName       → "Generated"
IConnectionFactoryName→ "IConnectionFactory"
IUnitOfWorkName       → "IUnitOfWork"
modelDefinition       → { properties: [], entity: {...} }
```

⚠️ **NO cambiar nombres sin actualizar templates**

### Code Style
- ✅ Nullable enabled (`<Nullable>enable</Nullable>`)
- ✅ ImplicitUsings enabled
- ✅ Target: .NET 10.0
- ✅ Usar `sealed` para clases que no deben heredarse
- ✅ Usar `init` para propiedades inmutables
- ✅ Interfaces prefijo `I` (ICodeGenerationEngine)
- ✅ Async methods sufijo `Async`

---

## Proceso de Cambios

### ANTES de modificar código:

1. **Lee la documentación:**
   - `LFT_ENGINE_DETAILED_REPORT.md` - Arquitectura completa
   - `TESTING_GUIDE.md` - Cómo están probados los componentes
   - Código existente del módulo afectado

2. **Propón un PLAN:**
   ```markdown
   ## Cambio Propuesto
   - Qué: [Descripción]
   - Por qué: [Justificación]
   - Dónde: [Archivos afectados]
   - Tests: [Qué tests agregar/modificar]
   - Riesgos: [Breaking changes, regresiones posibles]
   ```

3. **Verifica impacto:**
   - ¿Afecta contratos compartidos (Lft.Domain)?
   - ¿Rompe tests existentes?
   - ¿Afecta templates existentes?
   - ¿Necesita actualizar documentación?

### DESPUÉS de modificar código:

1. **Ejecutar tests:**
   ```bash
   dotnet test
   # Deben pasar los 96+ tests
   ```

2. **Actualizar documentación si:**
   - Cambiaste arquitectura → `LFT_ENGINE_DETAILED_REPORT.md`
   - Agregaste tests → `TESTING_GUIDE.md`
   - Cambiaste contratos → `docs/CHANGELOG-ARCH.md` (si existe)

3. **Commit message:**
   ```
   [Engine] Brief description

   - Detailed change 1
   - Detailed change 2

   Tests: Added/Modified X tests
   Breaking: Yes/No
   ```

---

## Extensibilidad - Cómo Agregar...

### Nuevo Variable Provider

1. Implementar `IVariableProvider`:
   ```csharp
   public class MyProvider : IVariableProvider
   {
       public void Populate(VariableContext ctx, GenerationRequest request)
       {
           ctx.Set("MyVariable", "value");
       }
   }
   ```

2. Registrar en CLI:
   ```csharp
   services.AddSingleton<IVariableProvider, MyProvider>();
   ```

3. **OBLIGATORIO:** Escribir tests (mínimo 5)

### Nuevo Template

1. Crear archivo `.liquid` en `templates/main/resources/`
2. Agregar step en `templates/main/_index.yml`:
   ```yaml
   - name: CreateMyFile
     action: create
     source: resources/my-template.liquid
     output: Output/{{ _ModelName }}File.cs
   ```
3. Usar variables existentes (verificar disponibilidad en `ConventionsVariableProvider`)

### Nuevo Command

1. Agregar entry point en YAML:
   ```yaml
   entryPoints:
     - name: MyCommand
       commandName: mycommand
       action: group
       steps: [...]
   ```

2. Ejecutar: `dotnet run -- gen mycommand EntityName`

---

## Limitaciones Conocidas (NO fijar sin plan)

1. **No soporta !include en YAML**
   - Workaround: YAML plano
   - Roadmap: Sprint 3

2. **Liquid no accede a objetos anónimos**
   - 4 tests fallan por esto
   - No afecta producción (templates no usan esta feature)
   - Workaround: Usar variables separadas

3. **Sin validación de templates**
   - Errores solo en runtime
   - Roadmap: Agregar schema validation

4. **Sin cache de templates**
   - Impacto bajo en performance (~100ms)
   - Roadmap: Agregar cache con invalidación

5. **Solo C# actualmente**
   - Roadmap: TypeScript/Python en Sprint 4

---

## Patrones de Diseño Utilizados

Respeta estos patrones al agregar código:

1. **Strategy Pattern** - `IVariableProvider`
2. **Template Method** - `StepExecutor.ExecuteAsync`
3. **Dependency Injection** - Todo el Engine
4. **Visitor Pattern** - `StepExecutor` (árbol de steps)
5. **Builder Pattern** - `VariableContext`

---

## Checklist de Calidad

Antes de marcar una tarea como completa:

- [ ] Código compila sin warnings
- [ ] Tests pasan (96+ de 100)
- [ ] Nuevos tests agregados para cambios
- [ ] Documentación actualizada si aplica
- [ ] No hay Console.WriteLine en Engine (usar logging)
- [ ] Interfaces no cambiaron (o hay plan de migración)
- [ ] Variables no cambiaron nombres (o templates actualizados)
- [ ] Performance no empeoró (generación < 200ms)

---

## Contactos / Referencias

- **Arquitectura completa:** `LFT_ENGINE_DETAILED_REPORT.md`
- **Guía de testing:** `TESTING_GUIDE.md`
- **Escenarios de test:** `TEST_SCENARIOS_EXPLAINED.md`
- **Tests:** `tests/Lft.Engine.Tests/`

---

## Versión de este documento

**Versión:** 1.0.0
**Última actualización:** 2025-11-24
**Autor:** Claude Code

**Changelog:**
- 2025-11-24: Versión inicial con reglas del proyecto LFT Engine
